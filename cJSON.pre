
# 1 "cJSON.c"

# 4 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\__size_t.h"
typedef unsigned size_t;

# 14 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\string.h"
extern void * memcpy(void *, const void *, size_t);
extern void * memmove(void *, const void *, size_t);
extern void * memset(void *, int, size_t);

# 36
extern char * strcat(char *, const char *);
extern char * strcpy(char *, const char *);
extern char * strncat(char *, const char *, size_t);
extern char * strncpy(char *, const char *, size_t);
extern char * strdup(const char *);
extern char * strtok(char *, const char *);


extern int memcmp(const void *, const void *, size_t);
extern int strcmp(const char *, const char *);
extern int stricmp(const char *, const char *);
extern int strncmp(const char *, const char *, size_t);
extern int strnicmp(const char *, const char *, size_t);
extern void * memchr(const void *, int, size_t);
extern size_t strcspn(const char *, const char *);
extern char * strpbrk(const char *, const char *);
extern size_t strspn(const char *, const char *);
extern char * strstr(const char *, const char *);
extern char * stristr(const char *, const char *);
extern char * strerror(int);
extern size_t strlen(const char *);
extern char * strchr(const char *, int);
extern char * strichr(const char *, int);
extern char * strrchr(const char *, int);
extern char * strrichr(const char *, int);

# 7 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\stdarg.h"
typedef void * va_list[1];

#pragma intrinsic(__va_start)
extern void * __va_start(void);

#pragma intrinsic(__va_arg)
extern void * __va_arg(void *, ...);

# 43 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\stdio.h"
struct __prbuf
{
char * ptr;
void (* func)(char);
};

# 29 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\errno.h"
extern int errno;

# 12 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\conio.h"
extern void init_uart(void);

extern char getch(void);
extern char getche(void);
extern void putch(char);
extern void ungetch(char);

extern __bit kbhit(void);

# 23
extern char * cgets(char *);
extern void cputs(const char *);

# 88 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\stdio.h"
extern int cprintf(char *, ...);
#pragma printf_check(cprintf)



extern int _doprnt(struct __prbuf *, const register char *, register va_list);


# 180
#pragma printf_check(vprintf) const
#pragma printf_check(vsprintf) const

extern char * gets(char *);
extern int puts(const char *);
extern int scanf(const char *, ...) __attribute__((unsupported("scanf() is not supported by this compiler")));
extern int sscanf(const char *, const char *, ...) __attribute__((unsupported("sscanf() is not supported by this compiler")));
extern int vprintf(const char *, va_list) __attribute__((unsupported("vprintf() is not supported by this compiler")));
extern int vsprintf(char *, const char *, va_list) __attribute__((unsupported("vsprintf() is not supported by this compiler")));
extern int vscanf(const char *, va_list ap) __attribute__((unsupported("vscanf() is not supported by this compiler")));
extern int vsscanf(const char *, const char *, va_list) __attribute__((unsupported("vsscanf() is not supported by this compiler")));

#pragma printf_check(printf) const
#pragma printf_check(sprintf) const
extern int sprintf(char *, const char *, ...);
extern int printf(const char *, ...);

# 30 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\math.h"
extern double fabs(double);
extern double floor(double);
extern double ceil(double);
extern double modf(double, double *);
extern double sqrt(double);
extern double atof(const char *);
extern double sin(double) ;
extern double cos(double) ;
extern double tan(double) ;
extern double asin(double) ;
extern double acos(double) ;
extern double atan(double);
extern double atan2(double, double) ;
extern double log(double);
extern double log10(double);
extern double pow(double, double) ;
extern double exp(double) ;
extern double sinh(double) ;
extern double cosh(double) ;
extern double tanh(double);
extern double eval_poly(double, const double *, int);
extern double frexp(double, int *);
extern double ldexp(double, int);
extern double fmod(double, double);
extern double trunc(double);
extern double round(double);

# 7 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\stdlib.h"
typedef unsigned short wchar_t;

# 15
typedef struct {
int rem;
int quot;
} div_t;
typedef struct {
unsigned rem;
unsigned quot;
} udiv_t;
typedef struct {
long quot;
long rem;
} ldiv_t;
typedef struct {
unsigned long quot;
unsigned long rem;
} uldiv_t;

# 65
extern double atof(const char *);
extern double strtod(const char *, const char **);
extern int atoi(const char *);
extern unsigned xtoi(const char *);
extern long atol(const char *);

# 73
extern long strtol(const char *, char **, int);

extern int rand(void);
extern void srand(unsigned int);
extern void * calloc(size_t, size_t);
extern div_t div(int numer, int denom);
extern udiv_t udiv(unsigned numer, unsigned denom);
extern ldiv_t ldiv(long numer, long denom);
extern uldiv_t uldiv(unsigned long numer,unsigned long denom);

# 85
extern unsigned long _lrotl(unsigned long value, unsigned int shift);
extern unsigned long _lrotr(unsigned long value, unsigned int shift);
extern unsigned int _rotl(unsigned int value, unsigned int shift);
extern unsigned int _rotr(unsigned int value, unsigned int shift);




extern void * malloc(size_t);
extern void free(void *);
extern void * realloc(void *, size_t);


# 13 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\xc8debug.h"
#pragma intrinsic(__builtin_software_breakpoint)
extern void __builtin_software_breakpoint(void);

# 104 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\stdlib.h"
extern int atexit(void (*)(void));
extern char * getenv(const char *);
extern char ** environ;
extern int system(char *);
extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
extern void * bsearch(const void *, void *, size_t, size_t, int(*)(const void *, const void *));
extern int abs(int);
extern long labs(long);

extern char * itoa(char * buf, int val, int base);
extern char * utoa(char * buf, unsigned val, int base);




extern char * ltoa(char * buf, long val, int base);
extern char * ultoa(char * buf, unsigned long val, int base);

extern char * ftoa(float f, int * status);

# 4 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\ctype.h"
extern __bit isalpha(char);
extern __bit isupper(char);
extern __bit islower(char);
extern __bit isdigit(char);
extern __bit isxdigit(char);
extern __bit isspace(char);
extern __bit ispunct(char);
extern __bit isalnum(char);
extern __bit isprint(char);
extern __bit isgraph(char);
extern __bit iscntrl(char);


extern char toupper(char);
extern char tolower(char);

# 6 "C:\Program Files (x86)\Microchip\xc8\v2.10\pic\include\c90\stddef.h"
typedef int ptrdiff_t;

# 103 "cJSON.h"
typedef struct cJSON
{

struct cJSON *next;
struct cJSON *prev;

struct cJSON *child;


int type;


char *valuestring;

int valueint;

double valuedouble;


char *string;
} cJSON;

typedef struct cJSON_Hooks
{

void *( *malloc_fn)(size_t sz);
void ( *free_fn)(void *ptr);
} cJSON_Hooks;

typedef int cJSON_bool;

# 141
const char* cJSON_Version(void);


void cJSON_InitHooks(cJSON_Hooks* hooks);



cJSON * cJSON_Parse(const char *value);
cJSON * cJSON_ParseWithLength(const char *value, size_t buffer_length);


cJSON * cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);
cJSON * cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);


char * cJSON_Print(const cJSON *item);

char * cJSON_PrintUnformatted(const cJSON *item);

char * cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);


cJSON_bool cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);

void cJSON_Delete(cJSON *item);


int cJSON_GetArraySize(const cJSON *array);

cJSON * cJSON_GetArrayItem(const cJSON *array, int index);

cJSON * cJSON_GetObjectItem(const cJSON * const object, const char * const string);
cJSON * cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
cJSON_bool cJSON_HasObjectItem(const cJSON *object, const char *string);

const char * cJSON_GetErrorPtr(void);


char * cJSON_GetStringValue(cJSON *item);
double cJSON_GetNumberValue(cJSON *item);


cJSON_bool cJSON_IsInvalid(const cJSON * const item);
cJSON_bool cJSON_IsFalse(const cJSON * const item);
cJSON_bool cJSON_IsTrue(const cJSON * const item);
cJSON_bool cJSON_IsBool(const cJSON * const item);
cJSON_bool cJSON_IsNull(const cJSON * const item);
cJSON_bool cJSON_IsNumber(const cJSON * const item);
cJSON_bool cJSON_IsString(const cJSON * const item);
cJSON_bool cJSON_IsArray(const cJSON * const item);
cJSON_bool cJSON_IsObject(const cJSON * const item);
cJSON_bool cJSON_IsRaw(const cJSON * const item);


cJSON * cJSON_CreateNull(void);
cJSON * cJSON_CreateTrue(void);
cJSON * cJSON_CreateFalse(void);
cJSON * cJSON_CreateBool(cJSON_bool boolean);
cJSON * cJSON_CreateNumber(double num);
cJSON * cJSON_CreateString(const char *string);

cJSON * cJSON_CreateRaw(const char *raw);
cJSON * cJSON_CreateArray(void);
cJSON * cJSON_CreateObject(void);

# 208
cJSON * cJSON_CreateStringReference(const char *string);

# 211
cJSON * cJSON_CreateObjectReference(const cJSON *child);
cJSON * cJSON_CreateArrayReference(const cJSON *child);

# 216
cJSON * cJSON_CreateIntArray(const int *numbers, int count);
cJSON * cJSON_CreateFloatArray(const float *numbers, int count);
cJSON * cJSON_CreateDoubleArray(const double *numbers, int count);
cJSON * cJSON_CreateStringArray(const char *const *strings, int count);


cJSON_bool cJSON_AddItemToArray(cJSON *array, cJSON *item);
cJSON_bool cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);

# 227
cJSON_bool cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);

cJSON_bool cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
cJSON_bool cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);


cJSON * cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
cJSON * cJSON_DetachItemFromArray(cJSON *array, int which);
void cJSON_DeleteItemFromArray(cJSON *array, int which);
cJSON * cJSON_DetachItemFromObject(cJSON *object, const char *string);
cJSON * cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
void cJSON_DeleteItemFromObject(cJSON *object, const char *string);
void cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);


cJSON_bool cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem);
cJSON_bool cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
cJSON_bool cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);
cJSON_bool cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
cJSON_bool cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);


cJSON * cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);

# 255
cJSON_bool cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);

# 260
void cJSON_Minify(char *json);

# 264
cJSON* cJSON_AddNullToObject(cJSON * const object, const char * const name);
cJSON* cJSON_AddTrueToObject(cJSON * const object, const char * const name);
cJSON* cJSON_AddFalseToObject(cJSON * const object, const char * const name);
cJSON* cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);
cJSON* cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);
cJSON* cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);
cJSON* cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);
cJSON* cJSON_AddObjectToObject(cJSON * const object, const char * const name);
cJSON* cJSON_AddArrayToObject(cJSON * const object, const char * const name);




double cJSON_SetNumberHelper(cJSON *object, double number);


char* cJSON_SetValuestring(cJSON *object, const char *valuestring);

# 286
void * cJSON_malloc(size_t size);
void cJSON_free(void *object);
char * jsonToString(int temp, int hum, int wind, char* sit);

# 84 "cJSON.c"
typedef struct {
const unsigned char *json;
size_t position;
} error;
static error global_error = { (0), 0 };

const char * cJSON_GetErrorPtr(void)
{
return (const char*) (global_error.json + global_error.position);
}

char * cJSON_GetStringValue(cJSON *item)
{
if (!cJSON_IsString(item))
{
return (0);
}

return item->valuestring;
}

double cJSON_GetNumberValue(cJSON *item)
{
if (!cJSON_IsNumber(item))
{
return 0.0;
}

return item->valuedouble;
}

# 120
const char* cJSON_Version(void)
{
static char version[15];
sprintf(version, "%i.%i.%i", 1, 7, 13);

return version;
}


static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
{
if ((string1 == (0)) || (string2 == (0)))
{
return 1;
}

if (string1 == string2)
{
return 0;
}

for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
{
if (*string1 == '\0')
{
return 0;
}
}

return tolower(*string1) - tolower(*string2);
}

typedef struct internal_hooks
{
void *( *allocate)(size_t size);
void ( *deallocate)(void *pointer);
void *( *reallocate)(void *pointer, size_t size);
} internal_hooks;

# 182
static internal_hooks global_hooks = { malloc, free, realloc };

static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
{
size_t length = 0;
unsigned char *copy = (0);

if (string == (0))
{
return (0);
}

length = strlen((const char*)string) + sizeof("");
copy = (unsigned char*)hooks->allocate(length);
if (copy == (0))
{
return (0);
}
memcpy(copy, string, length);

return copy;
}

void cJSON_InitHooks(cJSON_Hooks* hooks)
{
if (hooks == (0))
{

global_hooks.allocate = malloc;
global_hooks.deallocate = free;
global_hooks.reallocate = realloc;
return;
}

global_hooks.allocate = malloc;
if (hooks->malloc_fn != (0))
{
global_hooks.allocate = hooks->malloc_fn;
}

global_hooks.deallocate = free;
if (hooks->free_fn != (0))
{
global_hooks.deallocate = hooks->free_fn;
}


global_hooks.reallocate = (0);
if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
{
global_hooks.reallocate = realloc;
}
}


static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
{
cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
if (node)
{
memset(node, '\0', sizeof(cJSON));
}

return node;
}


void cJSON_Delete(cJSON *item)
{
cJSON *next = (0);
while (item != (0))
{
next = item->next;
if (!(item->type & 256) && (item->child != (0)))
{
cJSON_Delete(item->child);
}
if (!(item->type & 256) && (item->valuestring != (0)))
{
global_hooks.deallocate(item->valuestring);
}
if (!(item->type & 512) && (item->string != (0)))
{
global_hooks.deallocate(item->string);
}
global_hooks.deallocate(item);
item = next;
}
}


static unsigned char get_decimal_point(void)
{




return '.';

}

typedef struct
{
const unsigned char *content;
size_t length;
size_t offset;
size_t depth;
internal_hooks hooks;
} parse_buffer;

# 301
static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
{
double number = 0;
unsigned char *after_end = (0);
unsigned char number_c_string[64];
unsigned char decimal_point = get_decimal_point();
size_t i = 0;

if ((input_buffer == (0)) || (input_buffer->content == (0)))
{
return ((cJSON_bool)0);
}

# 317
for (i = 0; (i < (sizeof(number_c_string) - 1)) && ((input_buffer != (0)) && (((input_buffer)->offset + i) < (input_buffer)->length)); i++)
{
switch (((input_buffer)->content + (input_buffer)->offset)[i])
{
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
case '+':
case '-':
case 'e':
case 'E':
number_c_string[i] = ((input_buffer)->content + (input_buffer)->offset)[i];
break;

case '.':
number_c_string[i] = decimal_point;
break;

default:
goto loop_end;
}
}
loop_end:
number_c_string[i] = '\0';

number = strtod((const char*)number_c_string, (char**)&after_end);
if (number_c_string == after_end)
{
return ((cJSON_bool)0);
}

item->valuedouble = number;


if (number >= 32767)
{
item->valueint = 32767;
}
else if (number <= (double)(int)-32768)
{
item->valueint = (int)-32768;
}
else
{
item->valueint = (int)number;
}

item->type = (1 << 3);

input_buffer->offset += (size_t)(after_end - number_c_string);
return ((cJSON_bool)1);
}


double cJSON_SetNumberHelper(cJSON *object, double number)
{
if (number >= 32767)
{
object->valueint = 32767;
}
else if (number <= (double)(int)-32768)
{
object->valueint = (int)-32768;
}
else
{
object->valueint = (int)number;
}

return object->valuedouble = number;
}

char* cJSON_SetValuestring(cJSON *object, const char *valuestring)
{
char *copy = (0);

if (!(object->type & (1 << 4)) || (object->type & 256))
{
return (0);
}
if (strlen(valuestring) <= strlen(object->valuestring))
{
strcpy(object->valuestring, valuestring);
return object->valuestring;
}
copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);
if (copy == (0))
{
return (0);
}
if (object->valuestring != (0))
{
cJSON_free(object->valuestring);
}
object->valuestring = copy;

return copy;
}

typedef struct
{
unsigned char *buffer;
size_t length;
size_t offset;
size_t depth;
cJSON_bool noalloc;
cJSON_bool format;
internal_hooks hooks;
} printbuffer;


static unsigned char* ensure(printbuffer * const p, size_t needed)
{
unsigned char *newbuffer = (0);
size_t newsize = 0;

if ((p == (0)) || (p->buffer == (0)))
{
return (0);
}

if ((p->length > 0) && (p->offset >= p->length))
{

return (0);
}

if (needed > 32767)
{

return (0);
}

needed += p->offset + 1;
if (needed <= p->length)
{
return p->buffer + p->offset;
}

if (p->noalloc) {
return (0);
}


if (needed > (32767 / 2))
{

if (needed <= 32767)
{
newsize = 32767;
}
else
{
return (0);
}
}
else
{
newsize = needed * 2;
}

if (p->hooks.reallocate != (0))
{

newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
if (newbuffer == (0))
{
p->hooks.deallocate(p->buffer);
p->length = 0;
p->buffer = (0);

return (0);
}
}
else
{

newbuffer = (unsigned char*)p->hooks.allocate(newsize);
if (!newbuffer)
{
p->hooks.deallocate(p->buffer);
p->length = 0;
p->buffer = (0);

return (0);
}
if (newbuffer)
{
memcpy(newbuffer, p->buffer, p->offset + 1);
}
p->hooks.deallocate(p->buffer);
}
p->length = newsize;
p->buffer = newbuffer;

return newbuffer + p->offset;
}


static void update_offset(printbuffer * const buffer)
{
const unsigned char *buffer_pointer = (0);
if ((buffer == (0)) || (buffer->buffer == (0)))
{
return;
}
buffer_pointer = buffer->buffer + buffer->offset;

buffer->offset += strlen((const char*)buffer_pointer);
}


static cJSON_bool compare_double(double a, double b)
{
double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);
return (fabs(a - b) <= maxVal * (3.05176e-05));
}


static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
{
unsigned char *output_pointer = (0);
double d = item->valuedouble;
int length = 0;
size_t i = 0;
unsigned char number_buffer[26] = {0};
unsigned char decimal_point = get_decimal_point();
double test = 0.0;

if (output_buffer == (0))
{
return ((cJSON_bool)0);
}


if ((d != d) || (((d - d) != (d - d)) && !(d != d)))
{
length = sprintf((char*)number_buffer, "null");
}
else
{

length = sprintf((char*)number_buffer, "%1.15g", d);


if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
{

length = sprintf((char*)number_buffer, "%1.17g", d);
}
}


if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
{
return ((cJSON_bool)0);
}


output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}

# 591
for (i = 0; i < ((size_t)length); i++)
{
if (number_buffer[i] == decimal_point)
{
output_pointer[i] = '.';
continue;
}

output_pointer[i] = number_buffer[i];
}
output_pointer[i] = '\0';

output_buffer->offset += (size_t)length;

return ((cJSON_bool)1);
}


static unsigned parse_hex4(const unsigned char * const input)
{
unsigned int h = 0;
size_t i = 0;

for (i = 0; i < 4; i++)
{

if ((input[i] >= '0') && (input[i] <= '9'))
{
h += (unsigned int) input[i] - '0';
}
else if ((input[i] >= 'A') && (input[i] <= 'F'))
{
h += (unsigned int) 10 + input[i] - 'A';
}
else if ((input[i] >= 'a') && (input[i] <= 'f'))
{
h += (unsigned int) 10 + input[i] - 'a';
}
else
{
return 0;
}

if (i < 3)
{

h = h << 4;
}
}

return h;
}

# 646
static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
{
long unsigned int codepoint = 0;
unsigned int first_code = 0;
const unsigned char *first_sequence = input_pointer;
unsigned char utf8_length = 0;
unsigned char utf8_position = 0;
unsigned char sequence_length = 0;
unsigned char first_byte_mark = 0;

if ((input_end - first_sequence) < 6)
{

goto fail;
}


first_code = parse_hex4(first_sequence + 2);


if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
{
goto fail;
}


if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
{
const unsigned char *second_sequence = first_sequence + 6;
unsigned int second_code = 0;
sequence_length = 12;

if ((input_end - second_sequence) < 6)
{

goto fail;
}

if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
{

goto fail;
}


second_code = parse_hex4(second_sequence + 2);

if ((second_code < 0xDC00) || (second_code > 0xDFFF))
{

goto fail;
}



codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
}
else
{
sequence_length = 6;
codepoint = first_code;
}

# 712
if (codepoint < 0x80)
{

utf8_length = 1;
}
else if (codepoint < 0x800)
{

utf8_length = 2;
first_byte_mark = 0xC0;
}
else if (codepoint < 0x10000)
{

utf8_length = 3;
first_byte_mark = 0xE0;
}
else if (codepoint <= 0x10FFFF)
{

utf8_length = 4;
first_byte_mark = 0xF0;
}
else
{

goto fail;
}


for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
{

(*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
codepoint >>= 6;
}

if (utf8_length > 1)
{
(*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
}
else
{
(*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
}

*output_pointer += utf8_length;

return sequence_length;

fail:
return 0;
}


static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
{
const unsigned char *input_pointer = ((input_buffer)->content + (input_buffer)->offset) + 1;
const unsigned char *input_end = ((input_buffer)->content + (input_buffer)->offset) + 1;
unsigned char *output_pointer = (0);
unsigned char *output = (0);


if (((input_buffer)->content + (input_buffer)->offset)[0] != '\"')
{
goto fail;
}

{

size_t allocation_length = 0;
size_t skipped_bytes = 0;
while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
{

if (input_end[0] == '\\')
{
if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
{

goto fail;
}
skipped_bytes++;
input_end++;
}
input_end++;
}
if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
{
goto fail;
}


allocation_length = (size_t) (input_end - ((input_buffer)->content + (input_buffer)->offset)) - skipped_bytes;
output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
if (output == (0))
{
goto fail;
}
}

output_pointer = output;

while (input_pointer < input_end)
{
if (*input_pointer != '\\')
{
*output_pointer++ = *input_pointer++;
}

else
{
unsigned char sequence_length = 2;
if ((input_end - input_pointer) < 1)
{
goto fail;
}

switch (input_pointer[1])
{
case 'b':
*output_pointer++ = '\b';
break;
case 'f':
*output_pointer++ = '\f';
break;
case 'n':
*output_pointer++ = '\n';
break;
case 'r':
*output_pointer++ = '\r';
break;
case 't':
*output_pointer++ = '\t';
break;
case '\"':
case '\\':
case '/':
*output_pointer++ = input_pointer[1];
break;


case 'u':
sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
if (sequence_length == 0)
{

goto fail;
}
break;

default:
goto fail;
}
input_pointer += sequence_length;
}
}


*output_pointer = '\0';

item->type = (1 << 4);
item->valuestring = (char*)output;

input_buffer->offset = (size_t) (input_end - input_buffer->content);
input_buffer->offset++;

return ((cJSON_bool)1);

fail:
if (output != (0))
{
input_buffer->hooks.deallocate(output);
}

if (input_pointer != (0))
{
input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
}

return ((cJSON_bool)0);
}


static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
{
const unsigned char *input_pointer = (0);
unsigned char *output = (0);
unsigned char *output_pointer = (0);
size_t output_length = 0;

size_t escape_characters = 0;

if (output_buffer == (0))
{
return ((cJSON_bool)0);
}


if (input == (0))
{
output = ensure(output_buffer, sizeof("\"\""));
if (output == (0))
{
return ((cJSON_bool)0);
}
strcpy((char*)output, "\"\"");

return ((cJSON_bool)1);
}


for (input_pointer = input; *input_pointer; input_pointer++)
{
switch (*input_pointer)
{
case '\"':
case '\\':
case '\b':
case '\f':
case '\n':
case '\r':
case '\t':

escape_characters++;
break;
default:
if (*input_pointer < 32)
{

escape_characters += 5;
}
break;
}
}
output_length = (size_t)(input_pointer - input) + escape_characters;

output = ensure(output_buffer, output_length + sizeof("\"\""));
if (output == (0))
{
return ((cJSON_bool)0);
}


if (escape_characters == 0)
{
output[0] = '\"';
memcpy(output + 1, input, output_length);
output[output_length + 1] = '\"';
output[output_length + 2] = '\0';

return ((cJSON_bool)1);
}

output[0] = '\"';
output_pointer = output + 1;

for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
{
if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
{

*output_pointer = *input_pointer;
}
else
{

*output_pointer++ = '\\';
switch (*input_pointer)
{
case '\\':
*output_pointer = '\\';
break;
case '\"':
*output_pointer = '\"';
break;
case '\b':
*output_pointer = 'b';
break;
case '\f':
*output_pointer = 'f';
break;
case '\n':
*output_pointer = 'n';
break;
case '\r':
*output_pointer = 'r';
break;
case '\t':
*output_pointer = 't';
break;
default:

sprintf((char*)output_pointer, "u%04x", *input_pointer);
output_pointer += 4;
break;
}
}
}
output[output_length + 1] = '\"';
output[output_length + 2] = '\0';

return ((cJSON_bool)1);
}


static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
{
return print_string_ptr((unsigned char*)item->valuestring, p);
}


static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);


static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
{
if ((buffer == (0)) || (buffer->content == (0)))
{
return (0);
}

if ((!((buffer != (0)) && (((buffer)->offset + 0) < (buffer)->length))))
{
return buffer;
}

while (((buffer != (0)) && (((buffer)->offset + 0) < (buffer)->length)) && (((buffer)->content + (buffer)->offset)[0] <= 32))
{
buffer->offset++;
}

if (buffer->offset == buffer->length)
{
buffer->offset--;
}

return buffer;
}


static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
{
if ((buffer == (0)) || (buffer->content == (0)) || (buffer->offset != 0))
{
return (0);
}

if (((buffer != (0)) && (((buffer)->offset + 4) < (buffer)->length)) && (strncmp((const char*)((buffer)->content + (buffer)->offset), "\xEF\xBB\xBF", 3) == 0))
{
buffer->offset += 3;
}

return buffer;
}

cJSON * cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
{
size_t buffer_length;

if ((0) == value)
{
return (0);
}


buffer_length = strlen(value) + sizeof("");

return cJSON_ParseWithLengthOpts(value, buffer_length, return_parse_end, require_null_terminated);
}


cJSON * cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)
{
parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
cJSON *item = (0);


global_error.json = (0);
global_error.position = 0;

if (value == (0) || 0 == buffer_length)
{
goto fail;
}

buffer.content = (const unsigned char*)value;
buffer.length = buffer_length;
buffer.offset = 0;
buffer.hooks = global_hooks;

item = cJSON_New_Item(&global_hooks);
if (item == (0))
{
goto fail;
}

if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
{

goto fail;
}


if (require_null_terminated)
{
buffer_skip_whitespace(&buffer);
if ((buffer.offset >= buffer.length) || ((&buffer)->content + (&buffer)->offset)[0] != '\0')
{
goto fail;
}
}
if (return_parse_end)
{
*return_parse_end = (const char*)((&buffer)->content + (&buffer)->offset);
}

return item;

fail:
if (item != (0))
{
cJSON_Delete(item);
}

if (value != (0))
{
error local_error;
local_error.json = (const unsigned char*)value;
local_error.position = 0;

if (buffer.offset < buffer.length)
{
local_error.position = buffer.offset;
}
else if (buffer.length > 0)
{
local_error.position = buffer.length - 1;
}

if (return_parse_end != (0))
{
*return_parse_end = (const char*)local_error.json + local_error.position;
}

global_error = local_error;
}

return (0);
}


cJSON * cJSON_Parse(const char *value)
{
return cJSON_ParseWithOpts(value, 0, 0);
}

cJSON * cJSON_ParseWithLength(const char *value, size_t buffer_length)
{
return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);
}



static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
{
static const size_t default_buffer_size = 256;
printbuffer buffer[1];
unsigned char *printed = (0);

memset(buffer, 0, sizeof(buffer));


buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
buffer->length = default_buffer_size;
buffer->format = format;
buffer->hooks = *hooks;
if (buffer->buffer == (0))
{
goto fail;
}


if (!print_value(item, buffer))
{
goto fail;
}
update_offset(buffer);


if (hooks->reallocate != (0))
{
printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
if (printed == (0)) {
goto fail;
}
buffer->buffer = (0);
}
else
{
printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
if (printed == (0))
{
goto fail;
}
memcpy(printed, buffer->buffer, (((buffer->length) < (buffer->offset + 1)) ? (buffer->length) : (buffer->offset + 1)));
printed[buffer->offset] = '\0';


hooks->deallocate(buffer->buffer);
}

return printed;

fail:
if (buffer->buffer != (0))
{
hooks->deallocate(buffer->buffer);
}

if (printed != (0))
{
hooks->deallocate(printed);
}

return (0);
}


char * cJSON_Print(const cJSON *item)
{
return (char*)print(item, ((cJSON_bool)1), &global_hooks);
}

char * cJSON_PrintUnformatted(const cJSON *item)
{
return (char*)print(item, ((cJSON_bool)0), &global_hooks);
}

char * cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
{
printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };

if (prebuffer < 0)
{
return (0);
}

p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
if (!p.buffer)
{
return (0);
}

p.length = (size_t)prebuffer;
p.offset = 0;
p.noalloc = ((cJSON_bool)0);
p.format = fmt;
p.hooks = global_hooks;

if (!print_value(item, &p))
{
global_hooks.deallocate(p.buffer);
return (0);
}

return (char*)p.buffer;
}

cJSON_bool cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
{
printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };

if ((length < 0) || (buffer == (0)))
{
return ((cJSON_bool)0);
}

p.buffer = (unsigned char*)buffer;
p.length = (size_t)length;
p.offset = 0;
p.noalloc = ((cJSON_bool)1);
p.format = format;
p.hooks = global_hooks;

return print_value(item, &p);
}


static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
{
if ((input_buffer == (0)) || (input_buffer->content == (0)))
{
return ((cJSON_bool)0);
}



if (((input_buffer != (0)) && (((input_buffer)->offset + 4) <= (input_buffer)->length)) && (strncmp((const char*)((input_buffer)->content + (input_buffer)->offset), "null", 4) == 0))
{
item->type = (1 << 2);
input_buffer->offset += 4;
return ((cJSON_bool)1);
}

if (((input_buffer != (0)) && (((input_buffer)->offset + 5) <= (input_buffer)->length)) && (strncmp((const char*)((input_buffer)->content + (input_buffer)->offset), "false", 5) == 0))
{
item->type = (1 << 0);
input_buffer->offset += 5;
return ((cJSON_bool)1);
}

if (((input_buffer != (0)) && (((input_buffer)->offset + 4) <= (input_buffer)->length)) && (strncmp((const char*)((input_buffer)->content + (input_buffer)->offset), "true", 4) == 0))
{
item->type = (1 << 1);
item->valueint = 1;
input_buffer->offset += 4;
return ((cJSON_bool)1);
}

if (((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length)) && (((input_buffer)->content + (input_buffer)->offset)[0] == '\"'))
{
return parse_string(item, input_buffer);
}

if (((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length)) && ((((input_buffer)->content + (input_buffer)->offset)[0] == '-') || ((((input_buffer)->content + (input_buffer)->offset)[0] >= '0') && (((input_buffer)->content + (input_buffer)->offset)[0] <= '9'))))
{
return parse_number(item, input_buffer);
}

if (((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length)) && (((input_buffer)->content + (input_buffer)->offset)[0] == '['))
{
return parse_array(item, input_buffer);
}

if (((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length)) && (((input_buffer)->content + (input_buffer)->offset)[0] == '{'))
{
return parse_object(item, input_buffer);
}

return ((cJSON_bool)0);
}


static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
{
unsigned char *output = (0);

if ((item == (0)) || (output_buffer == (0)))
{
return ((cJSON_bool)0);
}

switch ((item->type) & 0xFF)
{
case (1 << 2):
output = ensure(output_buffer, 5);
if (output == (0))
{
return ((cJSON_bool)0);
}
strcpy((char*)output, "null");
return ((cJSON_bool)1);

case (1 << 0):
output = ensure(output_buffer, 6);
if (output == (0))
{
return ((cJSON_bool)0);
}
strcpy((char*)output, "false");
return ((cJSON_bool)1);

case (1 << 1):
output = ensure(output_buffer, 5);
if (output == (0))
{
return ((cJSON_bool)0);
}
strcpy((char*)output, "true");
return ((cJSON_bool)1);

case (1 << 3):
return print_number(item, output_buffer);

case (1 << 7):
{
size_t raw_length = 0;
if (item->valuestring == (0))
{
return ((cJSON_bool)0);
}

raw_length = strlen(item->valuestring) + sizeof("");
output = ensure(output_buffer, raw_length);
if (output == (0))
{
return ((cJSON_bool)0);
}
memcpy(output, item->valuestring, raw_length);
return ((cJSON_bool)1);
}

case (1 << 4):
return print_string(item, output_buffer);

case (1 << 5):
return print_array(item, output_buffer);

case (1 << 6):
return print_object(item, output_buffer);

default:
return ((cJSON_bool)0);
}
}


static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
{
cJSON *head = (0);
cJSON *current_item = (0);

if (input_buffer->depth >= 1000)
{
return ((cJSON_bool)0);
}
input_buffer->depth++;

if (((input_buffer)->content + (input_buffer)->offset)[0] != '[')
{

goto fail;
}

input_buffer->offset++;
buffer_skip_whitespace(input_buffer);
if (((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length)) && (((input_buffer)->content + (input_buffer)->offset)[0] == ']'))
{

goto success;
}


if ((!((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length))))
{
input_buffer->offset--;
goto fail;
}


input_buffer->offset--;

do
{

cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
if (new_item == (0))
{
goto fail;
}


if (head == (0))
{

current_item = head = new_item;
}
else
{

current_item->next = new_item;
new_item->prev = current_item;
current_item = new_item;
}


input_buffer->offset++;
buffer_skip_whitespace(input_buffer);
if (!parse_value(current_item, input_buffer))
{
goto fail;
}
buffer_skip_whitespace(input_buffer);
}
while (((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length)) && (((input_buffer)->content + (input_buffer)->offset)[0] == ','));

if ((!((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length))) || ((input_buffer)->content + (input_buffer)->offset)[0] != ']')
{
goto fail;
}

success:
input_buffer->depth--;

item->type = (1 << 5);
item->child = head;

input_buffer->offset++;

return ((cJSON_bool)1);

fail:
if (head != (0))
{
cJSON_Delete(head);
}

return ((cJSON_bool)0);
}


static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
{
unsigned char *output_pointer = (0);
size_t length = 0;
cJSON *current_element = item->child;

if (output_buffer == (0))
{
return ((cJSON_bool)0);
}



output_pointer = ensure(output_buffer, 1);
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}

*output_pointer = '[';
output_buffer->offset++;
output_buffer->depth++;

while (current_element != (0))
{
if (!print_value(current_element, output_buffer))
{
return ((cJSON_bool)0);
}
update_offset(output_buffer);
if (current_element->next)
{
length = (size_t) (output_buffer->format ? 2 : 1);
output_pointer = ensure(output_buffer, length + 1);
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}
*output_pointer++ = ',';
if(output_buffer->format)
{
*output_pointer++ = ' ';
}
*output_pointer = '\0';
output_buffer->offset += length;
}
current_element = current_element->next;
}

output_pointer = ensure(output_buffer, 2);
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}
*output_pointer++ = ']';
*output_pointer = '\0';
output_buffer->depth--;

return ((cJSON_bool)1);
}


static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
{
cJSON *head = (0);
cJSON *current_item = (0);

if (input_buffer->depth >= 1000)
{
return ((cJSON_bool)0);
}
input_buffer->depth++;

if ((!((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length))) || (((input_buffer)->content + (input_buffer)->offset)[0] != '{'))
{
goto fail;
}

input_buffer->offset++;
buffer_skip_whitespace(input_buffer);
if (((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length)) && (((input_buffer)->content + (input_buffer)->offset)[0] == '}'))
{
goto success;
}


if ((!((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length))))
{
input_buffer->offset--;
goto fail;
}


input_buffer->offset--;

do
{

cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
if (new_item == (0))
{
goto fail;
}


if (head == (0))
{

current_item = head = new_item;
}
else
{

current_item->next = new_item;
new_item->prev = current_item;
current_item = new_item;
}


input_buffer->offset++;
buffer_skip_whitespace(input_buffer);
if (!parse_string(current_item, input_buffer))
{
goto fail;
}
buffer_skip_whitespace(input_buffer);


current_item->string = current_item->valuestring;
current_item->valuestring = (0);

if ((!((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length))) || (((input_buffer)->content + (input_buffer)->offset)[0] != ':'))
{
goto fail;
}


input_buffer->offset++;
buffer_skip_whitespace(input_buffer);
if (!parse_value(current_item, input_buffer))
{
goto fail;
}
buffer_skip_whitespace(input_buffer);
}
while (((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length)) && (((input_buffer)->content + (input_buffer)->offset)[0] == ','));

if ((!((input_buffer != (0)) && (((input_buffer)->offset + 0) < (input_buffer)->length))) || (((input_buffer)->content + (input_buffer)->offset)[0] != '}'))
{
goto fail;
}

success:
input_buffer->depth--;

item->type = (1 << 6);
item->child = head;

input_buffer->offset++;
return ((cJSON_bool)1);

fail:
if (head != (0))
{
cJSON_Delete(head);
}

return ((cJSON_bool)0);
}


static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
{
unsigned char *output_pointer = (0);
size_t length = 0;
cJSON *current_item = item->child;

if (output_buffer == (0))
{
return ((cJSON_bool)0);
}


length = (size_t) (output_buffer->format ? 2 : 1);
output_pointer = ensure(output_buffer, length + 1);
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}

*output_pointer++ = '{';
output_buffer->depth++;
if (output_buffer->format)
{
*output_pointer++ = '\n';
}
output_buffer->offset += length;

while (current_item)
{
if (output_buffer->format)
{
size_t i;
output_pointer = ensure(output_buffer, output_buffer->depth);
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}
for (i = 0; i < output_buffer->depth; i++)
{
*output_pointer++ = '\t';
}
output_buffer->offset += output_buffer->depth;
}


if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
{
return ((cJSON_bool)0);
}
update_offset(output_buffer);

length = (size_t) (output_buffer->format ? 2 : 1);
output_pointer = ensure(output_buffer, length);
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}
*output_pointer++ = ':';
if (output_buffer->format)
{
*output_pointer++ = '\t';
}
output_buffer->offset += length;


if (!print_value(current_item, output_buffer))
{
return ((cJSON_bool)0);
}
update_offset(output_buffer);


length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
output_pointer = ensure(output_buffer, length + 1);
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}
if (current_item->next)
{
*output_pointer++ = ',';
}

if (output_buffer->format)
{
*output_pointer++ = '\n';
}
*output_pointer = '\0';
output_buffer->offset += length;

current_item = current_item->next;
}

output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
if (output_pointer == (0))
{
return ((cJSON_bool)0);
}
if (output_buffer->format)
{
size_t i;
for (i = 0; i < (output_buffer->depth - 1); i++)
{
*output_pointer++ = '\t';
}
}
*output_pointer++ = '}';
*output_pointer = '\0';
output_buffer->depth--;

return ((cJSON_bool)1);
}


int cJSON_GetArraySize(const cJSON *array)
{
cJSON *child = (0);
size_t size = 0;

if (array == (0))
{
return 0;
}

child = array->child;

while(child != (0))
{
size++;
child = child->next;
}



return (int)size;
}

static cJSON* get_array_item(const cJSON *array, size_t index)
{
cJSON *current_child = (0);

if (array == (0))
{
return (0);
}

current_child = array->child;
while ((current_child != (0)) && (index > 0))
{
index--;
current_child = current_child->next;
}

return current_child;
}

cJSON * cJSON_GetArrayItem(const cJSON *array, int index)
{
if (index < 0)
{
return (0);
}

return get_array_item(array, (size_t)index);
}

static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
cJSON *current_element = (0);

if ((object == (0)) || (name == (0)))
{
return (0);
}

current_element = object->child;
if (case_sensitive)
{
while ((current_element != (0)) && (current_element->string != (0)) && (strcmp(name, current_element->string) != 0))
{
current_element = current_element->next;
}
}
else
{
while ((current_element != (0)) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
{
current_element = current_element->next;
}
}

if ((current_element == (0)) || (current_element->string == (0))) {
return (0);
}

return current_element;
}

cJSON * cJSON_GetObjectItem(const cJSON * const object, const char * const string)
{
return get_object_item(object, string, ((cJSON_bool)0));
}

cJSON * cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
{
return get_object_item(object, string, ((cJSON_bool)1));
}

cJSON_bool cJSON_HasObjectItem(const cJSON *object, const char *string)
{
return cJSON_GetObjectItem(object, string) ? 1 : 0;
}


static void suffix_object(cJSON *prev, cJSON *item)
{
prev->next = item;
item->prev = prev;
}


static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
{
cJSON *reference = (0);
if (item == (0))
{
return (0);
}

reference = cJSON_New_Item(hooks);
if (reference == (0))
{
return (0);
}

memcpy(reference, item, sizeof(cJSON));
reference->string = (0);
reference->type |= 256;
reference->next = reference->prev = (0);
return reference;
}

static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
{
cJSON *child = (0);

if ((item == (0)) || (array == (0)) || (array == item))
{
return ((cJSON_bool)0);
}

child = array->child;

# 1955
if (child == (0))
{

array->child = item;
item->prev = item;
item->next = (0);
}
else
{

if (child->prev)
{
suffix_object(child->prev, item);
array->child->prev = item;
}
else
{
while (child->next)
{
child = child->next;
}
suffix_object(child, item);
array->child->prev = item;
}
}

return ((cJSON_bool)1);
}


cJSON_bool cJSON_AddItemToArray(cJSON *array, cJSON *item)
{
return add_item_to_array(array, item);
}

# 1997
static void* cast_away_const(const void* string)
{
return (void*)string;
}

# 2006
static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
{
char *new_key = (0);
int new_type = (0);

if ((object == (0)) || (string == (0)) || (item == (0)) || (object == item))
{
return ((cJSON_bool)0);
}

if (constant_key)
{
new_key = (char*)cast_away_const(string);
new_type = item->type | 512;
}
else
{
new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
if (new_key == (0))
{
return ((cJSON_bool)0);
}

new_type = item->type & ~512;
}

if (!(item->type & 512) && (item->string != (0)))
{
hooks->deallocate(item->string);
}

item->string = new_key;
item->type = new_type;

return add_item_to_array(object, item);
}

cJSON_bool cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
{
return add_item_to_object(object, string, item, &global_hooks, ((cJSON_bool)0));
}


cJSON_bool cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
{
return add_item_to_object(object, string, item, &global_hooks, ((cJSON_bool)1));
}

cJSON_bool cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
{
if (array == (0))
{
return ((cJSON_bool)0);
}

return add_item_to_array(array, create_reference(item, &global_hooks));
}

cJSON_bool cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
{
if ((object == (0)) || (string == (0)))
{
return ((cJSON_bool)0);
}

return add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, ((cJSON_bool)0));
}

cJSON* cJSON_AddNullToObject(cJSON * const object, const char * const name)
{
cJSON *null = cJSON_CreateNull();
if (add_item_to_object(object, name, null, &global_hooks, ((cJSON_bool)0)))
{
return null;
}

cJSON_Delete(null);
return (0);
}

cJSON* cJSON_AddTrueToObject(cJSON * const object, const char * const name)
{
cJSON *true_item = cJSON_CreateTrue();
if (add_item_to_object(object, name, true_item, &global_hooks, ((cJSON_bool)0)))
{
return true_item;
}

cJSON_Delete(true_item);
return (0);
}

cJSON* cJSON_AddFalseToObject(cJSON * const object, const char * const name)
{
cJSON *false_item = cJSON_CreateFalse();
if (add_item_to_object(object, name, false_item, &global_hooks, ((cJSON_bool)0)))
{
return false_item;
}

cJSON_Delete(false_item);
return (0);
}

cJSON* cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
{
cJSON *bool_item = cJSON_CreateBool(boolean);
if (add_item_to_object(object, name, bool_item, &global_hooks, ((cJSON_bool)0)))
{
return bool_item;
}

cJSON_Delete(bool_item);
return (0);
}

cJSON* cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
{
cJSON *number_item = cJSON_CreateNumber(number);
if (add_item_to_object(object, name, number_item, &global_hooks, ((cJSON_bool)0)))
{
return number_item;
}

cJSON_Delete(number_item);
return (0);
}

cJSON* cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
{
cJSON *string_item = cJSON_CreateString(string);
if (add_item_to_object(object, name, string_item, &global_hooks, ((cJSON_bool)0)))
{
return string_item;
}

cJSON_Delete(string_item);
return (0);
}

cJSON* cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
{
cJSON *raw_item = cJSON_CreateRaw(raw);
if (add_item_to_object(object, name, raw_item, &global_hooks, ((cJSON_bool)0)))
{
return raw_item;
}

cJSON_Delete(raw_item);
return (0);
}

cJSON* cJSON_AddObjectToObject(cJSON * const object, const char * const name)
{
cJSON *object_item = cJSON_CreateObject();
if (add_item_to_object(object, name, object_item, &global_hooks, ((cJSON_bool)0)))
{
return object_item;
}

cJSON_Delete(object_item);
return (0);
}

cJSON* cJSON_AddArrayToObject(cJSON * const object, const char * const name)
{
cJSON *array = cJSON_CreateArray();
if (add_item_to_object(object, name, array, &global_hooks, ((cJSON_bool)0)))
{
return array;
}

cJSON_Delete(array);
return (0);
}

cJSON * cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
{
if ((parent == (0)) || (item == (0)))
{
return (0);
}

if (item != parent->child)
{

item->prev->next = item->next;
}
if (item->next != (0))
{

item->next->prev = item->prev;
}

if (item == parent->child)
{

parent->child = item->next;
}

item->prev = (0);
item->next = (0);

return item;
}

cJSON * cJSON_DetachItemFromArray(cJSON *array, int which)
{
if (which < 0)
{
return (0);
}

return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
}

void cJSON_DeleteItemFromArray(cJSON *array, int which)
{
cJSON_Delete(cJSON_DetachItemFromArray(array, which));
}

cJSON * cJSON_DetachItemFromObject(cJSON *object, const char *string)
{
cJSON *to_detach = cJSON_GetObjectItem(object, string);

return cJSON_DetachItemViaPointer(object, to_detach);
}

cJSON * cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
{
cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);

return cJSON_DetachItemViaPointer(object, to_detach);
}

void cJSON_DeleteItemFromObject(cJSON *object, const char *string)
{
cJSON_Delete(cJSON_DetachItemFromObject(object, string));
}

void cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
{
cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
}


cJSON_bool cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
{
cJSON *after_inserted = (0);

if (which < 0)
{
return ((cJSON_bool)0);
}

after_inserted = get_array_item(array, (size_t)which);
if (after_inserted == (0))
{
return add_item_to_array(array, newitem);
}

newitem->next = after_inserted;
newitem->prev = after_inserted->prev;
after_inserted->prev = newitem;
if (after_inserted == array->child)
{
array->child = newitem;
}
else
{
newitem->prev->next = newitem;
}
return ((cJSON_bool)1);
}

cJSON_bool cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
{
if ((parent == (0)) || (replacement == (0)) || (item == (0)))
{
return ((cJSON_bool)0);
}

if (replacement == item)
{
return ((cJSON_bool)1);
}

replacement->next = item->next;
replacement->prev = item->prev;

if (replacement->next != (0))
{
replacement->next->prev = replacement;
}
if (parent->child == item)
{
parent->child = replacement;
}
else
{

# 2309
if (replacement->prev != (0))
{
replacement->prev->next = replacement;
}
}

item->next = (0);
item->prev = (0);
cJSON_Delete(item);

return ((cJSON_bool)1);
}

cJSON_bool cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
{
if (which < 0)
{
return ((cJSON_bool)0);
}

return cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
}

static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
{
if ((replacement == (0)) || (string == (0)))
{
return ((cJSON_bool)0);
}


if (!(replacement->type & 512) && (replacement->string != (0)))
{
cJSON_free(replacement->string);
}
replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
replacement->type &= ~512;

return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
}

cJSON_bool cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
{
return replace_item_in_object(object, string, newitem, ((cJSON_bool)0));
}

cJSON_bool cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
{
return replace_item_in_object(object, string, newitem, ((cJSON_bool)1));
}


cJSON * cJSON_CreateNull(void)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if(item)
{
item->type = (1 << 2);
}

return item;
}

cJSON * cJSON_CreateTrue(void)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if(item)
{
item->type = (1 << 1);
}

return item;
}

cJSON * cJSON_CreateFalse(void)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if(item)
{
item->type = (1 << 0);
}

return item;
}

cJSON * cJSON_CreateBool(cJSON_bool boolean)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if(item)
{
item->type = boolean ? (1 << 1) : (1 << 0);
}

return item;
}

cJSON * cJSON_CreateNumber(double num)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if(item)
{
item->type = (1 << 3);
item->valuedouble = num;


if (num >= 32767)
{
item->valueint = 32767;
}
else if (num <= (double)(int)-32768)
{
item->valueint = (int)-32768;
}
else
{
item->valueint = (int)num;
}
}

return item;
}

cJSON * cJSON_CreateString(const char *string)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if(item)
{
item->type = (1 << 4);
item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
if(!item->valuestring)
{
cJSON_Delete(item);
return (0);
}
}

return item;
}

cJSON * cJSON_CreateStringReference(const char *string)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if (item != (0))
{
item->type = (1 << 4) | 256;
item->valuestring = (char*)cast_away_const(string);
}

return item;
}

cJSON * cJSON_CreateObjectReference(const cJSON *child)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if (item != (0)) {
item->type = (1 << 6) | 256;
item->child = (cJSON*)cast_away_const(child);
}

return item;
}

cJSON * cJSON_CreateArrayReference(const cJSON *child) {
cJSON *item = cJSON_New_Item(&global_hooks);
if (item != (0)) {
item->type = (1 << 5) | 256;
item->child = (cJSON*)cast_away_const(child);
}

return item;
}

cJSON * cJSON_CreateRaw(const char *raw)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if(item)
{
item->type = (1 << 7);
item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
if(!item->valuestring)
{
cJSON_Delete(item);
return (0);
}
}

return item;
}

cJSON * cJSON_CreateArray(void)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if(item)
{
item->type=(1 << 5);
}

return item;
}

cJSON * cJSON_CreateObject(void)
{
cJSON *item = cJSON_New_Item(&global_hooks);
if (item)
{
item->type = (1 << 6);
}

return item;
}


cJSON * cJSON_CreateIntArray(const int *numbers, int count)
{
size_t i = 0;
cJSON *n = (0);
cJSON *p = (0);
cJSON *a = (0);

if ((count < 0) || (numbers == (0)))
{
return (0);
}

a = cJSON_CreateArray();
for(i = 0; a && (i < (size_t)count); i++)
{
n = cJSON_CreateNumber(numbers[i]);
if (!n)
{
cJSON_Delete(a);
return (0);
}
if(!i)
{
a->child = n;
}
else
{
suffix_object(p, n);
}
p = n;
}

return a;
}

cJSON * cJSON_CreateFloatArray(const float *numbers, int count)
{
size_t i = 0;
cJSON *n = (0);
cJSON *p = (0);
cJSON *a = (0);

if ((count < 0) || (numbers == (0)))
{
return (0);
}

a = cJSON_CreateArray();

for(i = 0; a && (i < (size_t)count); i++)
{
n = cJSON_CreateNumber((double)numbers[i]);
if(!n)
{
cJSON_Delete(a);
return (0);
}
if(!i)
{
a->child = n;
}
else
{
suffix_object(p, n);
}
p = n;
}

return a;
}

cJSON * cJSON_CreateDoubleArray(const double *numbers, int count)
{
size_t i = 0;
cJSON *n = (0);
cJSON *p = (0);
cJSON *a = (0);

if ((count < 0) || (numbers == (0)))
{
return (0);
}

a = cJSON_CreateArray();

for(i = 0;a && (i < (size_t)count); i++)
{
n = cJSON_CreateNumber(numbers[i]);
if(!n)
{
cJSON_Delete(a);
return (0);
}
if(!i)
{
a->child = n;
}
else
{
suffix_object(p, n);
}
p = n;
}

return a;
}

cJSON * cJSON_CreateStringArray(const char *const *strings, int count)
{
size_t i = 0;
cJSON *n = (0);
cJSON *p = (0);
cJSON *a = (0);

if ((count < 0) || (strings == (0)))
{
return (0);
}

a = cJSON_CreateArray();

for (i = 0; a && (i < (size_t)count); i++)
{
n = cJSON_CreateString(strings[i]);
if(!n)
{
cJSON_Delete(a);
return (0);
}
if(!i)
{
a->child = n;
}
else
{
suffix_object(p,n);
}
p = n;
}

return a;
}


cJSON * cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
{
cJSON *newitem = (0);
cJSON *child = (0);
cJSON *next = (0);
cJSON *newchild = (0);


if (!item)
{
goto fail;
}

newitem = cJSON_New_Item(&global_hooks);
if (!newitem)
{
goto fail;
}

newitem->type = item->type & (~256);
newitem->valueint = item->valueint;
newitem->valuedouble = item->valuedouble;
if (item->valuestring)
{
newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
if (!newitem->valuestring)
{
goto fail;
}
}
if (item->string)
{
newitem->string = (item->type&512) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
if (!newitem->string)
{
goto fail;
}
}

if (!recurse)
{
return newitem;
}

child = item->child;
while (child != (0))
{
newchild = cJSON_Duplicate(child, ((cJSON_bool)1));
if (!newchild)
{
goto fail;
}
if (next != (0))
{

next->next = newchild;
newchild->prev = next;
next = newchild;
}
else
{

newitem->child = newchild;
next = newchild;
}
child = child->next;
}

return newitem;

fail:
if (newitem != (0))
{
cJSON_Delete(newitem);
}

return (0);
}

static void skip_oneline_comment(char **input)
{
*input += (sizeof("//") - sizeof(""));

for (; (*input)[0] != '\0'; ++(*input))
{
if ((*input)[0] == '\n') {
*input += (sizeof("\n") - sizeof(""));
return;
}
}
}

static void skip_multiline_comment(char **input)
{
*input += (sizeof("/*") - sizeof(""));

for (; (*input)[0] != '\0'; ++(*input))
{
if (((*input)[0] == '*') && ((*input)[1] == '/'))
{
*input += (sizeof("*/") - sizeof(""));
return;
}
}
}

static void minify_string(char **input, char **output) {
(*output)[0] = (*input)[0];
*input += (sizeof("\"") - sizeof(""));
*output += (sizeof("\"") - sizeof(""));


for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
(*output)[0] = (*input)[0];

if ((*input)[0] == '\"') {
(*output)[0] = '\"';
*input += (sizeof("\"") - sizeof(""));
*output += (sizeof("\"") - sizeof(""));
return;
} else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
(*output)[1] = (*input)[1];
*input += (sizeof("\"") - sizeof(""));
*output += (sizeof("\"") - sizeof(""));
}
}
}

void cJSON_Minify(char *json)
{
char *into = json;

if (json == (0))
{
return;
}

while (json[0] != '\0')
{
switch (json[0])
{
case ' ':
case '\t':
case '\r':
case '\n':
json++;
break;

case '/':
if (json[1] == '/')
{
skip_oneline_comment(&json);
}
else if (json[1] == '*')
{
skip_multiline_comment(&json);
} else {
json++;
}
break;

case '\"':
minify_string(&json, (char**)&into);
break;

default:
into[0] = json[0];
json++;
into++;
}
}


*into = '\0';
}

cJSON_bool cJSON_IsInvalid(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xFF) == (0);
}

cJSON_bool cJSON_IsFalse(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xFF) == (1 << 0);
}

cJSON_bool cJSON_IsTrue(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xff) == (1 << 1);
}


cJSON_bool cJSON_IsBool(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & ((1 << 1) | (1 << 0))) != 0;
}
cJSON_bool cJSON_IsNull(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xFF) == (1 << 2);
}

cJSON_bool cJSON_IsNumber(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xFF) == (1 << 3);
}

cJSON_bool cJSON_IsString(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xFF) == (1 << 4);
}

cJSON_bool cJSON_IsArray(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xFF) == (1 << 5);
}

cJSON_bool cJSON_IsObject(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xFF) == (1 << 6);
}

cJSON_bool cJSON_IsRaw(const cJSON * const item)
{
if (item == (0))
{
return ((cJSON_bool)0);
}

return (item->type & 0xFF) == (1 << 7);
}

cJSON_bool cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
{
if ((a == (0)) || (b == (0)) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
{
return ((cJSON_bool)0);
}


switch (a->type & 0xFF)
{
case (1 << 0):
case (1 << 1):
case (1 << 2):
case (1 << 3):
case (1 << 4):
case (1 << 7):
case (1 << 5):
case (1 << 6):
break;

default:
return ((cJSON_bool)0);
}


if (a == b)
{
return ((cJSON_bool)1);
}

switch (a->type & 0xFF)
{

case (1 << 0):
case (1 << 1):
case (1 << 2):
return ((cJSON_bool)1);

case (1 << 3):
if (compare_double(a->valuedouble, b->valuedouble))
{
return ((cJSON_bool)1);
}
return ((cJSON_bool)0);

case (1 << 4):
case (1 << 7):
if ((a->valuestring == (0)) || (b->valuestring == (0)))
{
return ((cJSON_bool)0);
}
if (strcmp(a->valuestring, b->valuestring) == 0)
{
return ((cJSON_bool)1);
}

return ((cJSON_bool)0);

case (1 << 5):
{
cJSON *a_element = a->child;
cJSON *b_element = b->child;

for (; (a_element != (0)) && (b_element != (0));)
{
if (!cJSON_Compare(a_element, b_element, case_sensitive))
{
return ((cJSON_bool)0);
}

a_element = a_element->next;
b_element = b_element->next;
}


if (a_element != b_element) {
return ((cJSON_bool)0);
}

return ((cJSON_bool)1);
}

case (1 << 6):
{
cJSON *a_element = (0);
cJSON *b_element = (0);
for(a_element = (a != (0)) ? (a)->child : (0); a_element != (0); a_element = a_element->next)
{

b_element = get_object_item(b, a_element->string, case_sensitive);
if (b_element == (0))
{
return ((cJSON_bool)0);
}

if (!cJSON_Compare(a_element, b_element, case_sensitive))
{
return ((cJSON_bool)0);
}
}

# 3044
for(b_element = (b != (0)) ? (b)->child : (0); b_element != (0); b_element = b_element->next)
{
a_element = get_object_item(a, b_element->string, case_sensitive);
if (a_element == (0))
{
return ((cJSON_bool)0);
}

if (!cJSON_Compare(b_element, a_element, case_sensitive))
{
return ((cJSON_bool)0);
}
}

return ((cJSON_bool)1);
}

default:
return ((cJSON_bool)0);
}
}

void * cJSON_malloc(size_t size)
{
return global_hooks.allocate(size);
}

void cJSON_free(void *object)
{
global_hooks.deallocate(object);
}

char * jsonToString(int temp, int hum, int wind, char* sit){
char *string = (0);
char tempStr[5];
cJSON *temperature = (0);
cJSON *humidity = (0);
cJSON *windVelocity = (0);
cJSON *situation = (0);


cJSON *jsonObject = cJSON_CreateObject();


sprintf(tempStr,"%d", temp);
temperature = cJSON_CreateString(tempStr);
cJSON_AddItemToObject(jsonObject, "temperature", temperature);
sprintf(tempStr,"%d", hum);
humidity = cJSON_CreateString(tempStr);
cJSON_AddItemToObject(jsonObject, "humidity", humidity);
sprintf(tempStr,"%d", wind);
windVelocity = cJSON_CreateString(tempStr);
cJSON_AddItemToObject(jsonObject, "windVelocity", windVelocity);
situation = cJSON_CreateString(sit);
cJSON_AddItemToObject(jsonObject, "situation", situation);


string = cJSON_Print(jsonObject);

cJSON_Delete(jsonObject);
return string;
}
